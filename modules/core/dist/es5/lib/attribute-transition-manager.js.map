{"version":3,"sources":["../../../src/lib/attribute-transition-manager.js"],"names":["noop","DEFAULT_TRANSITION_SETTINGS","duration","easing","t","onStart","onEnd","onInterrupt","AttributeTransitionManager","constructor","gl","id","attributeTransitions","needsRedraw","transform","numInstances","Transform","isSupported","log","warn","finalize","delete","attributeName","_removeTransition","update","attributes","transitions","opts","changedTransitions","hasChanged","_updateAttribute","attribute","supportsTransition","_createModel","sourceBuffers","feedbackBuffers","elementCount","hasAttribute","getAttributes","animatedAttributes","transition","buffer","attributeInTransition","setCurrentTime","currentTime","uniforms","updated","time","run","_createTransition","Transition","name","Attribute","bufferLayout","_invalidateModel","_swapBuffer","settings","getTransitionSetting","_triggerTransition","Object","keys","length","assign","_getNextTransitionStates","size","toState","constant","BaseAttribute","value","getBuffer","divisor","externalBuffer","fromState","toLength","fromLength","Buffer","getElementCount","data","Float32Array","usage","setData","fromBufferLayout","toBufferLayout","getData","enter","transitionSettings","start"],"mappings":";;;;;;;;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA,MAAMA,IAAI,GAAG,MAAM,CAAE,CAArB;;AACA,MAAMC,2BAA2B,GAAG;AAClCC,EAAAA,QAAQ,EAAE,CADwB;AAElCC,EAAAA,MAAM,EAAEC,CAAC,IAAIA,CAFqB;AAGlCC,EAAAA,OAAO,EAAEL,IAHyB;AAIlCM,EAAAA,KAAK,EAAEN,IAJ2B;AAKlCO,EAAAA,WAAW,EAAEP;AALqB,CAApC;;AAQe,MAAMQ,0BAAN,CAAiC;AAC9CC,EAAAA,WAAW,CAACC,EAAD,QAAW;AAAA,QAAN;AAACC,MAAAA;AAAD,KAAM;AACpB,SAAKA,EAAL,GAAUA,EAAV;AACA,SAAKD,EAAL,GAAUA,EAAV;AAEA,SAAKE,oBAAL,GAA4B,EAA5B;AACA,SAAKC,WAAL,GAAmB,KAAnB;AACA,SAAKC,SAAL,GAAiB,IAAjB;AACA,SAAKC,YAAL,GAAoB,CAApB;;AAEA,QAAIC,gBAAUC,WAAV,CAAsBP,EAAtB,CAAJ,EAA+B;AAC7B,WAAKO,WAAL,GAAmB,IAAnB;AACD,KAFD,MAEO,IAAIP,EAAJ,EAAQ;AAEbQ,mBAAIC,IAAJ,CAAS,yEAAT;AACD;AACF;;AAEDC,EAAAA,QAAQ,GAAG;AACT,QAAI,KAAKN,SAAT,EAAoB;AAClB,WAAKA,SAAL,CAAeO,MAAf;AACD;;AACD,SAAK,MAAMC,aAAX,IAA4B,KAAKV,oBAAjC,EAAuD;AACrD,WAAKW,iBAAL,CAAuBD,aAAvB;AACD;AACF;;AAMDE,EAAAA,MAAM,QAA+C;AAAA,QAA9C;AAACC,MAAAA,UAAD;AAAaC,MAAAA,WAAW,GAAG,EAA3B;AAA+BX,MAAAA;AAA/B,KAA8C;AACnD,SAAKY,IAAL,GAAYD,WAAZ;AAEA,SAAKX,YAAL,GAAoBA,YAAY,IAAI,CAApC;;AAEA,QAAI,CAAC,KAAKE,WAAV,EAAuB;AACrB;AACD;;AAED,UAAM;AAACL,MAAAA;AAAD,QAAyB,IAA/B;AACA,UAAMgB,kBAAkB,GAAG,EAA3B;;AAEA,SAAK,MAAMN,aAAX,IAA4BG,UAA5B,EAAwC;AACtC,YAAMI,UAAU,GAAG,KAAKC,gBAAL,CAAsBR,aAAtB,EAAqCG,UAAU,CAACH,aAAD,CAA/C,CAAnB;;AAEA,UAAIO,UAAJ,EAAgB;AACdD,QAAAA,kBAAkB,CAACN,aAAD,CAAlB,GAAoCV,oBAAoB,CAACU,aAAD,CAAxD;AACD;AACF;;AAED,SAAK,MAAMA,aAAX,IAA4BV,oBAA5B,EAAkD;AAChD,YAAMmB,SAAS,GAAGN,UAAU,CAACH,aAAD,CAA5B;;AAEA,UAAI,CAACS,SAAD,IAAc,CAACA,SAAS,CAACC,kBAAV,EAAnB,EAAmD;AAEjD,aAAKT,iBAAL,CAAuBD,aAAvB;AACD;AACF;;AAED,QAAI,CAAC,KAAKR,SAAV,EAAqB;AACnB,WAAKmB,YAAL;AACD,KAFD,MAEO,IAAI,KAAKnB,SAAT,EAAoB;AACzB,YAAM;AAACoB,QAAAA,aAAD;AAAgBC,QAAAA;AAAhB,UAAmC,0CAAWP,kBAAX,CAAzC;AACA,WAAKd,SAAL,CAAeU,MAAf,CAAsB;AACpBY,QAAAA,YAAY,EAAE,KAAKrB,YADC;AAEpBmB,QAAAA,aAFoB;AAGpBC,QAAAA;AAHoB,OAAtB;AAKD;AACF;;AAGDE,EAAAA,YAAY,CAACf,aAAD,EAAgB;AAC1B,WAAOA,aAAa,IAAI,KAAKV,oBAA7B;AACD;;AAGD0B,EAAAA,aAAa,GAAG;AACd,UAAMC,kBAAkB,GAAG,EAA3B;;AAEA,SAAK,MAAMjB,aAAX,IAA4B,KAAKV,oBAAjC,EAAuD;AACrD,YAAM4B,UAAU,GAAG,KAAK5B,oBAAL,CAA0BU,aAA1B,CAAnB;;AAEA,UAAIkB,UAAU,CAACC,MAAf,EAAuB;AACrBF,QAAAA,kBAAkB,CAACjB,aAAD,CAAlB,GAAoCkB,UAAU,CAACE,qBAA/C;AACD;AACF;;AAED,WAAOH,kBAAP;AACD;;AAKDI,EAAAA,cAAc,CAACC,WAAD,EAAc;AAC1B,QAAI,CAAC,KAAK9B,SAAN,IAAmB,KAAKC,YAAL,KAAsB,CAA7C,EAAgD;AAC9C,aAAO,KAAP;AACD;;AAED,UAAM8B,QAAQ,GAAG,EAAjB;AAEA,QAAIhC,WAAW,GAAG,KAAKA,WAAvB;AACA,SAAKA,WAAL,GAAmB,KAAnB;;AAEA,SAAK,MAAMS,aAAX,IAA4B,KAAKV,oBAAjC,EAAuD;AACrD,YAAM4B,UAAU,GAAG,KAAK5B,oBAAL,CAA0BU,aAA1B,CAAnB;AACA,YAAMwB,OAAO,GAAGN,UAAU,CAAChB,MAAX,CAAkBoB,WAAlB,CAAhB;;AACA,UAAIE,OAAJ,EAAa;AACXD,QAAAA,QAAQ,WAAIvB,aAAJ,UAAR,GAAmCkB,UAAU,CAACO,IAA9C;AACAlC,QAAAA,WAAW,GAAG,IAAd;AACD;AACF;;AAED,QAAIA,WAAJ,EAAiB;AACf,WAAKC,SAAL,CAAekC,GAAf,CAAmB;AAACH,QAAAA;AAAD,OAAnB;AACD;;AAED,WAAOhC,WAAP;AACD;;AAIDoC,EAAAA,iBAAiB,CAAC3B,aAAD,EAAgBS,SAAhB,EAA2B;AAC1C,QAAIS,UAAU,GAAG,KAAK5B,oBAAL,CAA0BU,aAA1B,CAAjB;;AACA,QAAI,CAACkB,UAAL,EAAiB;AACfA,MAAAA,UAAU,GAAG,IAAIU,mBAAJ,CAAe;AAC1BC,QAAAA,IAAI,EAAE7B,aADoB;AAE1BS,QAAAA,SAF0B;AAG1BW,QAAAA,qBAAqB,EAAE,IAAIU,kBAAJ,CAAc,KAAK1C,EAAnB,EAAuBqB,SAAvB,CAHG;AAI1BsB,QAAAA,YAAY,EAAEtB,SAAS,CAACsB;AAJE,OAAf,CAAb;AAMA,WAAKzC,oBAAL,CAA0BU,aAA1B,IAA2CkB,UAA3C;;AACA,WAAKc,gBAAL;;AACA,aAAOd,UAAP;AACD;;AACD,WAAO,IAAP;AACD;;AAEDjB,EAAAA,iBAAiB,CAACD,aAAD,EAAgB;AAC/B,UAAMkB,UAAU,GAAG,KAAK5B,oBAAL,CAA0BU,aAA1B,CAAnB;;AACA,QAAIkB,UAAJ,EAAgB;AACd,UAAIA,UAAU,CAACC,MAAf,EAAuB;AACrBD,QAAAA,UAAU,CAACC,MAAX,CAAkBpB,MAAlB;AACD;;AACD,UAAImB,UAAU,CAACe,WAAf,EAA4B;AAC1Bf,QAAAA,UAAU,CAACe,WAAX,CAAuBlC,MAAvB;AACD;;AACD,aAAO,KAAKT,oBAAL,CAA0BU,aAA1B,CAAP;;AACA,WAAKgC,gBAAL;AACD;AACF;;AAIDxB,EAAAA,gBAAgB,CAACR,aAAD,EAAgBS,SAAhB,EAA2B;AACzC,UAAMyB,QAAQ,GAAGzB,SAAS,CAAC0B,oBAAV,CAA+B,KAAK9B,IAApC,CAAjB;;AAEA,QAAI6B,QAAJ,EAAc;AACZ,UAAI3B,UAAJ;AACA,UAAIW,UAAU,GAAG,KAAK5B,oBAAL,CAA0BU,aAA1B,CAAjB;;AACA,UAAIkB,UAAJ,EAAgB;AACdX,QAAAA,UAAU,GAAGE,SAAS,CAAClB,WAAV,EAAb;AACD,OAFD,MAEO;AAEL2B,QAAAA,UAAU,GAAG,KAAKS,iBAAL,CAAuB3B,aAAvB,EAAsCS,SAAtC,CAAb;AACAF,QAAAA,UAAU,GAAG,IAAb;AACD;;AAED,UAAIA,UAAJ,EAAgB;AACd,aAAK6B,kBAAL,CAAwBlB,UAAxB,EAAoCgB,QAApC;;AACA,eAAO,IAAP;AACD;AACF;;AAED,WAAO,KAAP;AACD;;AAGDF,EAAAA,gBAAgB,GAAG;AACjB,QAAI,KAAKxC,SAAT,EAAoB;AAClB,WAAKA,SAAL,CAAeO,MAAf;AACA,WAAKP,SAAL,GAAiB,IAAjB;AACD;AACF;;AAGDmB,EAAAA,YAAY,GAAG;AACb,QAAI0B,MAAM,CAACC,IAAP,CAAY,KAAKhD,oBAAjB,EAAuCiD,MAAvC,KAAkD,CAAtD,EAAyD;AAEvD;AACD;;AACD,SAAK/C,SAAL,GAAiB,IAAIE,eAAJ,CACf,KAAKN,EADU,EAEfiD,MAAM,CAACG,MAAP,CACE;AACE1B,MAAAA,YAAY,EAAE,KAAKrB;AADrB,KADF,EAIE,0CAAW,KAAKH,oBAAhB,CAJF,EAKE,0CAAW,KAAKA,oBAAhB,CALF,CAFe,CAAjB;AAUD;;AAGDmD,EAAAA,wBAAwB,CAACvB,UAAD,EAAagB,QAAb,EAAuB;AAC7C,UAAM;AAACzB,MAAAA;AAAD,QAAcS,UAApB;AACA,UAAM;AAACwB,MAAAA;AAAD,QAASjC,SAAf;AAEA,QAAIkC,OAAJ;;AACA,QAAIlC,SAAS,CAACmC,QAAd,EAAwB;AACtBD,MAAAA,OAAO,GAAG,IAAIE,sBAAJ,CAAkB,KAAKzD,EAAvB,EAA2B;AAACwD,QAAAA,QAAQ,EAAE,IAAX;AAAiBE,QAAAA,KAAK,EAAErC,SAAS,CAACqC,KAAlC;AAAyCJ,QAAAA;AAAzC,OAA3B,CAAV;AACD,KAFD,MAEO;AACLC,MAAAA,OAAO,GAAG,IAAIE,sBAAJ,CAAkB,KAAKzD,EAAvB,EAA2B;AACnCwD,QAAAA,QAAQ,EAAE,KADyB;AAEnCzB,QAAAA,MAAM,EAAEV,SAAS,CAACsC,SAAV,EAF2B;AAGnCC,QAAAA,OAAO,EAAE,CAH0B;AAInCN,QAAAA,IAJmC;AAOnCI,QAAAA,KAAK,EAAErC,SAAS,CAACwC,cAAV,GAA2B,IAA3B,GAAkCxC,SAAS,CAACqC;AAPhB,OAA3B,CAAV;AASD;;AACD,UAAMI,SAAS,GAAGhC,UAAU,CAACC,MAAX,IAAqBwB,OAAvC;AACA,UAAMQ,QAAQ,GAAG,KAAK1D,YAAL,GAAoBiD,IAArC;AACA,UAAMU,UAAU,GAAIF,SAAS,YAAYG,YAArB,IAA+BH,SAAS,CAACI,eAAV,EAAhC,IAAgEH,QAAnF;AAKA,QAAIhC,MAAM,GAAGD,UAAU,CAACe,WAAxB;AACAf,IAAAA,UAAU,CAACe,WAAX,GAAyBf,UAAU,CAACC,MAApC;;AAEA,QAAI,CAACA,MAAL,EAAa;AACXA,MAAAA,MAAM,GAAG,IAAIkC,YAAJ,CAAW,KAAKjE,EAAhB,EAAoB;AAC3BmE,QAAAA,IAAI,EAAE,IAAIC,YAAJ,CAAiBL,QAAjB,CADqB;AAE3BM,QAAAA,KAAK;AAFsB,OAApB,CAAT;AAID,KALD,MAKO,IAAItC,MAAM,CAACmC,eAAP,KAA2BH,QAA/B,EAAyC;AAE9ChC,MAAAA,MAAM,CAACuC,OAAP,CAAe;AACbH,QAAAA,IAAI,EAAE,IAAIC,YAAJ,CAAiBL,QAAjB;AADO,OAAf;AAGD;;AAEDjC,IAAAA,UAAU,CAACE,qBAAX,CAAiClB,MAAjC,CAAwC;AAACiB,MAAAA;AAAD,KAAxC;AAEA,6CAAU;AACR+B,MAAAA,SADQ;AAERP,MAAAA,OAFQ;AAGRS,MAAAA,UAHQ;AAIRD,MAAAA,QAJQ;AAKRQ,MAAAA,gBAAgB,EAAEzC,UAAU,CAACa,YALrB;AAMR6B,MAAAA,cAAc,EAAEnD,SAAS,CAACsB,YANlB;AAOR8B,MAAAA,OAAO,EAAE3B,QAAQ,CAAC4B;AAPV,KAAV;AAUA5C,IAAAA,UAAU,CAACa,YAAX,GAA0BtB,SAAS,CAACsB,YAApC;AAEA,WAAO;AAACmB,MAAAA,SAAD;AAAYP,MAAAA,OAAZ;AAAqBxB,MAAAA;AAArB,KAAP;AACD;;AAIDiB,EAAAA,kBAAkB,CAAClB,UAAD,EAAagB,QAAb,EAAuB;AAEvC,yBAAOA,QAAQ,IAAIA,QAAQ,CAACtD,QAAT,GAAoB,CAAvC;AAEA,SAAKW,WAAL,GAAmB,IAAnB;AAEA,UAAMwE,kBAAkB,GAAG1B,MAAM,CAACG,MAAP,CAAc,EAAd,EAAkB7D,2BAAlB,EAA+CuD,QAA/C,CAA3B;AAGAhB,IAAAA,UAAU,CAAC8C,KAAX,CACE3B,MAAM,CAACG,MAAP,CAAc,EAAd,EAAkB,KAAKC,wBAAL,CAA8BvB,UAA9B,EAA0CgB,QAA1C,CAAlB,EAAuE6B,kBAAvE,CADF;AAGD;;AApR6C","sourcesContent":["import GL from '@luma.gl/constants';\nimport {Buffer, Transform} from '@luma.gl/core';\nimport {getShaders, getBuffers, padBuffer} from './attribute-transition-utils';\nimport Attribute from './attribute';\nimport BaseAttribute from './base-attribute';\nimport Transition from '../transitions/transition';\nimport log from '../utils/log';\nimport assert from '../utils/assert';\n\nconst noop = () => {};\nconst DEFAULT_TRANSITION_SETTINGS = {\n  duration: 0,\n  easing: t => t,\n  onStart: noop,\n  onEnd: noop,\n  onInterrupt: noop\n};\n\nexport default class AttributeTransitionManager {\n  constructor(gl, {id}) {\n    this.id = id;\n    this.gl = gl;\n\n    this.attributeTransitions = {};\n    this.needsRedraw = false;\n    this.transform = null;\n    this.numInstances = 0;\n\n    if (Transform.isSupported(gl)) {\n      this.isSupported = true;\n    } else if (gl) {\n      // This class may be instantiated without a WebGL context (e.g. web worker)\n      log.warn('WebGL2 not supported by this browser. Transition animation is disabled.')();\n    }\n  }\n\n  finalize() {\n    if (this.transform) {\n      this.transform.delete();\n    }\n    for (const attributeName in this.attributeTransitions) {\n      this._removeTransition(attributeName);\n    }\n  }\n\n  /* Public methods */\n\n  // Called when attribute manager updates\n  // Check the latest attributes for updates.\n  update({attributes, transitions = {}, numInstances}) {\n    this.opts = transitions;\n    // Transform class will crash if elementCount is 0\n    this.numInstances = numInstances || 1;\n\n    if (!this.isSupported) {\n      return;\n    }\n\n    const {attributeTransitions} = this;\n    const changedTransitions = {};\n\n    for (const attributeName in attributes) {\n      const hasChanged = this._updateAttribute(attributeName, attributes[attributeName]);\n\n      if (hasChanged) {\n        changedTransitions[attributeName] = attributeTransitions[attributeName];\n      }\n    }\n\n    for (const attributeName in attributeTransitions) {\n      const attribute = attributes[attributeName];\n\n      if (!attribute || !attribute.supportsTransition()) {\n        // Animated attribute has been removed\n        this._removeTransition(attributeName);\n      }\n    }\n\n    if (!this.transform) {\n      this._createModel();\n    } else if (this.transform) {\n      const {sourceBuffers, feedbackBuffers} = getBuffers(changedTransitions);\n      this.transform.update({\n        elementCount: this.numInstances,\n        sourceBuffers,\n        feedbackBuffers\n      });\n    }\n  }\n\n  // Returns `true` if attribute is transition-enabled\n  hasAttribute(attributeName) {\n    return attributeName in this.attributeTransitions;\n  }\n\n  // Get all the animated attributes\n  getAttributes() {\n    const animatedAttributes = {};\n\n    for (const attributeName in this.attributeTransitions) {\n      const transition = this.attributeTransitions[attributeName];\n\n      if (transition.buffer) {\n        animatedAttributes[attributeName] = transition.attributeInTransition;\n      }\n    }\n\n    return animatedAttributes;\n  }\n\n  /* eslint-disable max-statements */\n  // Called every render cycle, run transform feedback\n  // Returns `true` if anything changes\n  setCurrentTime(currentTime) {\n    if (!this.transform || this.numInstances === 0) {\n      return false;\n    }\n\n    const uniforms = {};\n\n    let needsRedraw = this.needsRedraw;\n    this.needsRedraw = false;\n\n    for (const attributeName in this.attributeTransitions) {\n      const transition = this.attributeTransitions[attributeName];\n      const updated = transition.update(currentTime);\n      if (updated) {\n        uniforms[`${attributeName}Time`] = transition.time;\n        needsRedraw = true;\n      }\n    }\n\n    if (needsRedraw) {\n      this.transform.run({uniforms});\n    }\n\n    return needsRedraw;\n  }\n  /* eslint-enable max-statements */\n\n  /* Private methods */\n  _createTransition(attributeName, attribute) {\n    let transition = this.attributeTransitions[attributeName];\n    if (!transition) {\n      transition = new Transition({\n        name: attributeName,\n        attribute,\n        attributeInTransition: new Attribute(this.gl, attribute),\n        bufferLayout: attribute.bufferLayout\n      });\n      this.attributeTransitions[attributeName] = transition;\n      this._invalidateModel();\n      return transition;\n    }\n    return null;\n  }\n\n  _removeTransition(attributeName) {\n    const transition = this.attributeTransitions[attributeName];\n    if (transition) {\n      if (transition.buffer) {\n        transition.buffer.delete();\n      }\n      if (transition._swapBuffer) {\n        transition._swapBuffer.delete();\n      }\n      delete this.attributeTransitions[attributeName];\n      this._invalidateModel();\n    }\n  }\n\n  // Check an attributes for updates\n  // Returns a transition object if a new transition is triggered.\n  _updateAttribute(attributeName, attribute) {\n    const settings = attribute.getTransitionSetting(this.opts);\n\n    if (settings) {\n      let hasChanged;\n      let transition = this.attributeTransitions[attributeName];\n      if (transition) {\n        hasChanged = attribute.needsRedraw();\n      } else {\n        // New animated attributes have been added\n        transition = this._createTransition(attributeName, attribute);\n        hasChanged = true;\n      }\n\n      if (hasChanged) {\n        this._triggerTransition(transition, settings);\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  // Invalidates the current model\n  _invalidateModel() {\n    if (this.transform) {\n      this.transform.delete();\n      this.transform = null;\n    }\n  }\n\n  // Create a model for the transform feedback\n  _createModel() {\n    if (Object.keys(this.attributeTransitions).length === 0) {\n      // no transitions\n      return;\n    }\n    this.transform = new Transform(\n      this.gl,\n      Object.assign(\n        {\n          elementCount: this.numInstances\n        },\n        getBuffers(this.attributeTransitions),\n        getShaders(this.attributeTransitions)\n      )\n    );\n  }\n\n  // get current values of an attribute, clipped/padded to the size of the new buffer\n  _getNextTransitionStates(transition, settings) {\n    const {attribute} = transition;\n    const {size} = attribute;\n\n    let toState;\n    if (attribute.constant) {\n      toState = new BaseAttribute(this.gl, {constant: true, value: attribute.value, size});\n    } else {\n      toState = new BaseAttribute(this.gl, {\n        constant: false,\n        buffer: attribute.getBuffer(),\n        divisor: 0,\n        size,\n        // attribute's `value` does not match the content of external buffer,\n        // will need to call buffer.getData if needed\n        value: attribute.externalBuffer ? null : attribute.value\n      });\n    }\n    const fromState = transition.buffer || toState;\n    const toLength = this.numInstances * size;\n    const fromLength = (fromState instanceof Buffer && fromState.getElementCount()) || toLength;\n\n    // Alternate between two buffers when new transitions start.\n    // Last destination buffer is used as an attribute (from state),\n    // And the other buffer is now the destination buffer.\n    let buffer = transition._swapBuffer;\n    transition._swapBuffer = transition.buffer;\n\n    if (!buffer) {\n      buffer = new Buffer(this.gl, {\n        data: new Float32Array(toLength),\n        usage: GL.DYNAMIC_COPY\n      });\n    } else if (buffer.getElementCount() < toLength) {\n      // Pad buffers to be the same length\n      buffer.setData({\n        data: new Float32Array(toLength)\n      });\n    }\n\n    transition.attributeInTransition.update({buffer});\n\n    padBuffer({\n      fromState,\n      toState,\n      fromLength,\n      toLength,\n      fromBufferLayout: transition.bufferLayout,\n      toBufferLayout: attribute.bufferLayout,\n      getData: settings.enter\n    });\n\n    transition.bufferLayout = attribute.bufferLayout;\n\n    return {fromState, toState, buffer};\n  }\n\n  // Start a new transition using the current settings\n  // Updates transition state and from/to buffer\n  _triggerTransition(transition, settings) {\n    // Check if settings is valid\n    assert(settings && settings.duration > 0);\n\n    this.needsRedraw = true;\n\n    const transitionSettings = Object.assign({}, DEFAULT_TRANSITION_SETTINGS, settings);\n\n    // Attribute descriptor to transition from\n    transition.start(\n      Object.assign({}, this._getNextTransitionStates(transition, settings), transitionSettings)\n    );\n  }\n}\n"],"file":"attribute-transition-manager.js"}