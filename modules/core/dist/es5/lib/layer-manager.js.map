{"version":3,"sources":["../../../src/lib/layer-manager.js"],"names":["LOG_PRIORITY_LIFECYCLE","LOG_PRIORITY_LIFECYCLE_MINOR","INITIAL_CONTEXT","Object","seal","layerManager","deck","gl","time","useDevicePixels","stats","shaderCache","pickingFBO","animationProps","userData","layerName","layer","Layer","LayerManager","constructor","viewport","lastRenderedLayers","layers","context","assign","ShaderCache","_cachePrograms","Stats","id","Viewport","_needsRedraw","_needsUpdate","_debug","activateViewport","bind","_initSeer","_editSeer","finalize","_finalizeLayer","seer","removeListener","needsRedraw","opts","clearRedrawFlags","_checkIfNeedsRedraw","needsUpdate","setNeedsRedraw","reason","setNeedsUpdate","getLayers","layerIds","filter","find","layerId","indexOf","setProps","props","debug","setLayers","newLayers","log","Boolean","error","generatedLayers","_updateLayers","oldLayers","updateLayers","redraw","layerNeedsRedraw","getNeedsRedraw","oldViewport","viewportChanged","equals","setChangeFlags","_updateLayer","oldLayerMap","oldLayer","warn","_updateSublayersRecursively","error2","_finalizeOldLayers","firstError","newLayer","sublayers","validateProps","err","_initializeLayer","_transferLayerState","push","isComposite","getSubLayers","_initialize","lifecycle","LIFECYCLE","INITIALIZED","internalState","model","getModels","_transferState","MATCHED","AWAITING_GC","printChangeFlags","_update","AWAITING_FINALIZATION","_finalize","FINALIZED","forEach","payload","type","valuePath","itemKey","slice","value"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport assert from '../utils/assert';\nimport {_ShaderCache as ShaderCache} from '@luma.gl/core';\nimport seer from 'seer';\nimport Layer from './layer';\nimport {LIFECYCLE} from '../lifecycle/constants';\nimport log from '../utils/log';\nimport {flatten} from '../utils/flatten';\nimport {Stats} from 'probe.gl';\n\nimport Viewport from '../viewports/viewport';\n\nimport {\n  setPropOverrides,\n  layerEditListener,\n  seerInitListener,\n  initLayerInSeer,\n  updateLayerInSeer\n} from './seer-integration';\n\nconst LOG_PRIORITY_LIFECYCLE = 2;\nconst LOG_PRIORITY_LIFECYCLE_MINOR = 4;\n\n// CONTEXT IS EXPOSED TO LAYERS\nconst INITIAL_CONTEXT = Object.seal({\n  layerManager: null,\n  deck: null,\n  gl: null,\n  time: -1,\n\n  // Settings\n  useDevicePixels: true, // Exposed in case custom layers need to adjust sizes\n\n  // General resources\n  stats: null, // for tracking lifecycle performance\n\n  // GL Resources\n  shaderCache: null,\n  pickingFBO: null, // Screen-size framebuffer that layers can reuse\n\n  animationProps: null,\n\n  userData: {} // Place for any custom app `context`\n});\n\nconst layerName = layer => (layer instanceof Layer ? `${layer}` : !layer ? 'null' : 'invalid');\n\nexport default class LayerManager {\n  // eslint-disable-next-line\n  constructor(gl, {deck, stats, viewport = null} = {}) {\n    // Currently deck.gl expects the DeckGL.layers array to be different\n    // whenever React rerenders. If the same layers array is used, the\n    // LayerManager's diffing algorithm will generate a fatal error and\n    // break the rendering.\n\n    // `this.lastRenderedLayers` stores the UNFILTERED layers sent\n    // down to LayerManager, so that `layers` reference can be compared.\n    // If it's the same across two React render calls, the diffing logic\n    // will be skipped.\n    this.lastRenderedLayers = [];\n    this.layers = [];\n\n    this.context = Object.assign({}, INITIAL_CONTEXT, {\n      layerManager: this,\n      deck,\n      gl,\n      // Enabling luma.gl Program caching using private API (_cachePrograms)\n      shaderCache: gl && new ShaderCache({gl, _cachePrograms: true}),\n      stats: stats || new Stats({id: 'deck.gl'}),\n      // Make sure context.viewport is not empty on the first layer initialization\n      viewport: viewport || new Viewport({id: 'DEFAULT-INITIAL-VIEWPORT'}) // Current viewport, exposed to layers for project* function\n    });\n\n    this._needsRedraw = 'Initial render';\n    this._needsUpdate = false;\n    this._debug = false;\n\n    this.activateViewport = this.activateViewport.bind(this);\n\n    // Seer integration\n    this._initSeer = this._initSeer.bind(this);\n    this._editSeer = this._editSeer.bind(this);\n\n    Object.seal(this);\n\n    seerInitListener(this._initSeer);\n    layerEditListener(this._editSeer);\n  }\n\n  // Method to call when the layer manager is not needed anymore.\n  // Currently used in the <DeckGL> componentWillUnmount lifecycle to unbind Seer listeners.\n  finalize() {\n    // Finalize all layers\n    for (const layer of this.layers) {\n      this._finalizeLayer(layer);\n    }\n\n    seer.removeListener(this._initSeer);\n    seer.removeListener(this._editSeer);\n  }\n\n  // Check if a redraw is needed\n  needsRedraw(opts = {clearRedrawFlags: false}) {\n    return this._checkIfNeedsRedraw(opts);\n  }\n\n  // Check if a deep update of all layers is needed\n  needsUpdate() {\n    return this._needsUpdate;\n  }\n\n  // Layers will be redrawn (in next animation frame)\n  setNeedsRedraw(reason) {\n    this._needsRedraw = this._needsRedraw || reason;\n  }\n\n  // Layers will be updated deeply (in next animation frame)\n  // Potentially regenerating attributes and sub layers\n  setNeedsUpdate(reason) {\n    this._needsUpdate = this._needsUpdate || reason;\n  }\n\n  // Gets an (optionally) filtered list of layers\n  getLayers({layerIds = null} = {}) {\n    // Filtering by layerId compares beginning of strings, so that sublayers will be included\n    // Dependes on the convention of adding suffixes to the parent's layer name\n    return layerIds\n      ? this.layers.filter(layer => layerIds.find(layerId => layer.id.indexOf(layerId) === 0))\n      : this.layers;\n  }\n\n  /**\n   * Set props needed for layer rendering and picking.\n   * Parameters are to be passed as a single object, with the following values:\n   * @param {Boolean} useDevicePixels\n   */\n  /* eslint-disable complexity, max-statements */\n  setProps(props) {\n    if ('debug' in props) {\n      this._debug = props.debug;\n    }\n\n    // A way for apps to add data to context that can be accessed in layers\n    if ('userData' in props) {\n      this.context.userData = props.userData;\n    }\n\n    if ('useDevicePixels' in props) {\n      this.context.useDevicePixels = props.useDevicePixels;\n    }\n\n    // TODO - For now we set layers before viewports to preserve changeFlags\n    if ('layers' in props) {\n      this.setLayers(props.layers);\n    }\n  }\n  /* eslint-enable complexity, max-statements */\n\n  // Supply a new layer list, initiating sublayer generation and layer matching\n  setLayers(newLayers) {\n    // TODO - something is generating state updates that cause rerender of the same\n    if (newLayers === this.lastRenderedLayers) {\n      log.log(3, 'Ignoring layer update due to layer array not changed')();\n      return this;\n    }\n    this.lastRenderedLayers = newLayers;\n\n    newLayers = flatten(newLayers, {filter: Boolean});\n\n    for (const layer of newLayers) {\n      layer.context = this.context;\n    }\n\n    const {error, generatedLayers} = this._updateLayers({\n      oldLayers: this.layers,\n      newLayers\n    });\n\n    this.layers = generatedLayers;\n\n    // Throw first error found, if any\n    if (error) {\n      throw error;\n    }\n    return this;\n  }\n\n  // Update layers from last cycle if `setNeedsUpdate()` has been called\n  updateLayers(animationProps = {}) {\n    if ('time' in animationProps) {\n      this.context.time = animationProps.time;\n    }\n    // NOTE: For now, even if only some layer has changed, we update all layers\n    // to ensure that layer id maps etc remain consistent even if different\n    // sublayers are rendered\n    const reason = this.needsUpdate();\n    if (reason) {\n      this.setNeedsRedraw(`updating layers: ${reason}`);\n      // HACK - Call with a copy of lastRenderedLayers to trigger a full update\n      this.setLayers([...this.lastRenderedLayers]);\n    }\n  }\n\n  //\n  // PRIVATE METHODS\n  //\n\n  _checkIfNeedsRedraw(opts) {\n    let redraw = this._needsRedraw;\n    if (opts.clearRedrawFlags) {\n      this._needsRedraw = false;\n    }\n\n    // This layers list doesn't include sublayers, relying on composite layers\n    for (const layer of this.layers) {\n      // Call every layer to clear their flags\n      const layerNeedsRedraw = layer.getNeedsRedraw(opts);\n      redraw = redraw || layerNeedsRedraw;\n    }\n\n    return redraw;\n  }\n\n  // Make a viewport \"current\" in layer context, updating viewportChanged flags\n  activateViewport(viewport) {\n    const oldViewport = this.context.viewport;\n    const viewportChanged = !oldViewport || !viewport.equals(oldViewport);\n\n    if (viewportChanged) {\n      log.log(4, 'Viewport changed', viewport)();\n\n      this.context.viewport = viewport;\n\n      // Update layers states\n      // Let screen space layers update their state based on viewport\n      for (const layer of this.layers) {\n        layer.setChangeFlags({viewportChanged: 'Viewport changed'});\n        this._updateLayer(layer);\n      }\n    }\n\n    assert(this.context.viewport, 'LayerManager: viewport not set');\n\n    return this;\n  }\n\n  // Match all layers, checking for caught errors\n  // To avoid having an exception in one layer disrupt other layers\n  // TODO - mark layers with exceptions as bad and remove from rendering cycle?\n  _updateLayers({oldLayers, newLayers}) {\n    // Create old layer map\n    const oldLayerMap = {};\n    for (const oldLayer of oldLayers) {\n      if (oldLayerMap[oldLayer.id]) {\n        log.warn(`Multiple old layers with same id ${layerName(oldLayer)}`)();\n      } else {\n        oldLayerMap[oldLayer.id] = oldLayer;\n      }\n    }\n\n    // Allocate array for generated layers\n    const generatedLayers = [];\n\n    // Match sublayers\n    const error = this._updateSublayersRecursively({\n      newLayers,\n      oldLayerMap,\n      generatedLayers\n    });\n\n    // Finalize unmatched layers\n    const error2 = this._finalizeOldLayers(oldLayerMap);\n\n    this._needsUpdate = false;\n\n    const firstError = error || error2;\n    return {error: firstError, generatedLayers};\n  }\n\n  /* eslint-disable complexity,max-statements */\n  // Note: adds generated layers to `generatedLayers` array parameter\n  _updateSublayersRecursively({newLayers, oldLayerMap, generatedLayers}) {\n    let error = null;\n\n    for (const newLayer of newLayers) {\n      newLayer.context = this.context;\n\n      // Given a new coming layer, find its matching old layer (if any)\n      const oldLayer = oldLayerMap[newLayer.id];\n      if (oldLayer === null) {\n        // null, rather than undefined, means this id was originally there\n        log.warn(`Multiple new layers with same id ${layerName(newLayer)}`)();\n      }\n      // Remove the old layer from candidates, as it has been matched with this layer\n      oldLayerMap[newLayer.id] = null;\n\n      let sublayers = null;\n\n      // We must not generate exceptions until after layer matching is complete\n      try {\n        if (this._debug && oldLayer !== newLayer) {\n          newLayer.validateProps();\n        }\n\n        if (!oldLayer) {\n          const err = this._initializeLayer(newLayer);\n          error = error || err;\n          initLayerInSeer(newLayer); // Initializes layer in seer chrome extension (if connected)\n        } else {\n          this._transferLayerState(oldLayer, newLayer);\n          const err = this._updateLayer(newLayer);\n          error = error || err;\n          updateLayerInSeer(newLayer); // Updates layer in seer chrome extension (if connected)\n        }\n        generatedLayers.push(newLayer);\n\n        // Call layer lifecycle method: render sublayers\n        sublayers = newLayer.isComposite && newLayer.getSubLayers();\n        // End layer lifecycle method: render sublayers\n      } catch (err) {\n        log.warn(`error during matching of ${layerName(newLayer)}`, err)();\n        error = error || err; // Record first exception\n      }\n\n      if (sublayers) {\n        const err = this._updateSublayersRecursively({\n          newLayers: sublayers,\n          oldLayerMap,\n          generatedLayers\n        });\n        error = error || err;\n      }\n    }\n\n    return error;\n  }\n  /* eslint-enable complexity,max-statements */\n\n  // Finalize any old layers that were not matched\n  _finalizeOldLayers(oldLayerMap) {\n    let error = null;\n    for (const layerId in oldLayerMap) {\n      const layer = oldLayerMap[layerId];\n      if (layer) {\n        error = error || this._finalizeLayer(layer);\n      }\n    }\n    return error;\n  }\n\n  // EXCEPTION SAFE LAYER ACCESS\n\n  // Initializes a single layer, calling layer methods\n  _initializeLayer(layer) {\n    log.log(LOG_PRIORITY_LIFECYCLE, `initializing ${layerName(layer)}`)();\n\n    let error = null;\n    try {\n      layer._initialize();\n      layer.lifecycle = LIFECYCLE.INITIALIZED;\n    } catch (err) {\n      log.warn(`error while initializing ${layerName(layer)}\\n`, err)();\n      error = error || err;\n      // TODO - what should the lifecycle state be here? LIFECYCLE.INITIALIZATION_FAILED?\n    }\n\n    // Set back pointer (used in picking)\n    layer.internalState.layer = layer;\n\n    // Save layer on model for picking purposes\n    // store on model.userData rather than directly on model\n    for (const model of layer.getModels()) {\n      model.userData.layer = layer;\n    }\n\n    return error;\n  }\n\n  _transferLayerState(oldLayer, newLayer) {\n    newLayer._transferState(oldLayer);\n    newLayer.lifecycle = LIFECYCLE.MATCHED;\n\n    if (newLayer !== oldLayer) {\n      log.log(\n        LOG_PRIORITY_LIFECYCLE_MINOR,\n        `matched ${layerName(newLayer)}`,\n        oldLayer,\n        '->',\n        newLayer\n      )();\n      oldLayer.lifecycle = LIFECYCLE.AWAITING_GC;\n    } else {\n      log.log(LOG_PRIORITY_LIFECYCLE_MINOR, `Matching layer is unchanged ${newLayer.id}`)();\n    }\n  }\n\n  // Updates a single layer, cleaning all flags\n  _updateLayer(layer) {\n    log.log(\n      LOG_PRIORITY_LIFECYCLE_MINOR,\n      `updating ${layer} because: ${layer.printChangeFlags()}`\n    )();\n    let error = null;\n    try {\n      layer._update();\n    } catch (err) {\n      log.warn(`error during update of ${layerName(layer)}`, err)();\n      // Save first error\n      error = err;\n    }\n    return error;\n  }\n\n  // Finalizes a single layer\n  _finalizeLayer(layer) {\n    assert(layer.lifecycle !== LIFECYCLE.AWAITING_FINALIZATION);\n    layer.lifecycle = LIFECYCLE.AWAITING_FINALIZATION;\n    let error = null;\n    this.setNeedsRedraw(`finalized ${layerName(layer)}`);\n    try {\n      layer._finalize();\n    } catch (err) {\n      log.warn(`error during finalization of ${layerName(layer)}`, err)();\n      error = err;\n    }\n    layer.lifecycle = LIFECYCLE.FINALIZED;\n    log.log(LOG_PRIORITY_LIFECYCLE, `finalizing ${layerName(layer)}`)();\n    return error;\n  }\n\n  // SEER INTEGRATION\n\n  /**\n   * Called upon Seer initialization, manually sends layers data.\n   */\n  _initSeer() {\n    this.layers.forEach(layer => {\n      initLayerInSeer(layer);\n      updateLayerInSeer(layer);\n    });\n  }\n\n  /**\n   * On Seer property edition, set override and update layers.\n   */\n  _editSeer(payload) {\n    if (payload.type !== 'edit' || payload.valuePath[0] !== 'props') {\n      return;\n    }\n\n    setPropOverrides(payload.itemKey, payload.valuePath.slice(1), payload.value);\n    this.updateLayers();\n  }\n}\n"],"file":"layer-manager.js"}